/*
 * Copyright (C) 2018-2024 University of Waterloo.
 *
 * This file is part of Perses.
 *
 * Perses is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3, or (at your option) any later version.
 *
 * Perses is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Perses; see the file LICENSE.  If not see <http://www.gnu.org/licenses/>.
 */
package org.pluverse.cs241.assembler

import java.io.ByteArrayOutputStream

class CodeGenVisitor : Arm64AsmBaseVisitor<Arm64Instruction?>() {
  // Buffer to store generated machine code bytes
  private val baos = ByteArrayOutputStream()

  // Get the generated byte array
  val machineCode: ByteArray
    get() = baos.toByteArray()

  // ---------- Visit Program Entry ----------
  override fun visitProgram(ctx: Arm64AsmParser.ProgramContext): Arm64Instruction? {
    for (line in ctx.line()) {
      val instr = visit(line)
      if (instr != null) {
        baos.write(instr.encode())
      }
    }

    ctx.lastline()?.let { 
      val instr = visit(it)
      if (instr != null) {
        baos.write(instr.encode())
      }
    }
    return null
  }

  // ---------- Visit Line and Lastline ----------
  override fun visitLine(ctx: Arm64AsmParser.LineContext): Arm64Instruction? {
    if (ctx.statement() != null) {
      return visit(ctx.statement())
    }
    return null
  }

  override fun visitLastline(ctx: Arm64AsmParser.LastlineContext): Arm64Instruction? {
    if (ctx.statement() != null) {
      return visit(ctx.statement())
    }
    return null
  }

  override fun visitAdd3(ctx: Arm64AsmParser.Add3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return AddInstruction(rd, rn, rm)
  }

  override fun visitSub3(ctx: Arm64AsmParser.Sub3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return SubInstruction(rd, rn, rm)
  }

  override fun visitMul3(ctx: Arm64AsmParser.Mul3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return MulInstruction(rd, rn, rm)
  }

  override fun visitSmulh3(ctx: Arm64AsmParser.Smulh3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return SmulhInstruction(rd, rn, rm)
  }

  override fun visitUmulh3(ctx: Arm64AsmParser.Umulh3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return UmulhInstruction(rd, rn, rm)
  }

  override fun visitSdiv3(ctx: Arm64AsmParser.Sdiv3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return SdivInstruction(rd, rn, rm)
  }

  override fun visitUdiv3(ctx: Arm64AsmParser.Udiv3Context): Arm64Instruction? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)
    return UdivInstruction(rd, rn, rm)
  }

  override fun visitCmpInstr(ctx: Arm64AsmParser.CmpInstrContext): Arm64Instruction? {
    val rn = parseReg(ctx.reg(0).text)
    val rm = parseReg(ctx.reg(1).text)
    return CmpInstruction(rn, rm)
  }

  override fun visitBrReg(ctx: Arm64AsmParser.BrRegContext): Arm64Instruction? {
    val rn = parseReg(ctx.reg().text)
    return BrInstruction(rn)
  }

  override fun visitBlrReg(ctx: Arm64AsmParser.BlrRegContext): Arm64Instruction? {
    val rn = parseReg(ctx.reg().text)
    return BlrInstruction(rn)
  }

  companion object {


    internal fun parseReg(regName: String): Int {
      if (regName == "xzr") return 31
      if (regName == "sp") return 31
      // Remove 'x' prefix and parse as integer
      return regName.substring(1).toInt()
    }

    internal fun parseImmediate(imm: String): Long {
      if (imm.startsWith("0x") || imm.startsWith("0X")) {
        return imm.substring(2).toLong(16)
      }
      return imm.toLong()
    }
  }
}
