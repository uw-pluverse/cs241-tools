/*
 * Copyright (C) 2018-2024 University of Waterloo.
 *
 * This file is part of Perses.
 *
 * Perses is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3, or (at your option) any later version.
 *
 * Perses is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Perses; see the file LICENSE.  If not see <http://www.gnu.org/licenses/>.
 */
package org.pluverse.cs241.assembler

import java.io.ByteArrayOutputStream

class CodeGenVisitor : Arm64AsmBaseVisitor<Void?>() {
  // Buffer to store generated machine code bytes
  private val baos = ByteArrayOutputStream()

  // Get the generated byte array
  val machineCode: ByteArray
    get() = baos.toByteArray()

  // Helper: write 32-bit integer in Little Endian
  private fun emit32(val_: Int) {
    baos.write(val_ and 0xFF)
    baos.write((val_ shr 8) and 0xFF)
    baos.write((val_ shr 16) and 0xFF)
    baos.write((val_ shr 24) and 0xFF)
  }

  // Helper: write 64-bit integer in Little Endian (.8byte)
  private fun emit64(val_: Long) {
    emit32((val_ and 0xFFFFFFFFL).toInt())
    emit32((val_ ushr 32).toInt())
  }

  // Helper: parse register, e.g., "x0" -> 0, "x10" -> 10
  private fun parseReg(regName: String): Int {
    if (regName == "xzr") return 31
    if (regName == "sp") return 31
    // Remove 'x' prefix and parse as integer
    return regName.substring(1).toInt()
  }

  // Helper: parse immediate value
  private fun parseImm(imm: String): Long {
    if (imm.startsWith("0x") || imm.startsWith("0X")) {
      return imm.substring(2).toLong(16)
    }
    return imm.toLong()
  }

  // ---------- Visit Program Entry ----------
  override fun visitProgram(ctx: Arm64AsmParser.ProgramContext): Void? {
    // Visit all statements
    for (st in ctx.statement()) {
      visit(st)
    }
    return null
  }

  // ---------- Implement Instruction Encoding (Example: ADD) ----------
  override fun visitAdd3(ctx: Arm64AsmParser.Add3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b10001011001 shl 21
    val flags = 0b011000 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitSub3(ctx: Arm64AsmParser.Sub3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b11001011001 shl 21
    val flags = 0b011000 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitMul3(ctx: Arm64AsmParser.Mul3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b10011011000 shl 21
    val flags = 0b011111 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitSmulh3(ctx: Arm64AsmParser.Smulh3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b10011011010 shl 21
    val flags = 0b011111 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitUmulh3(ctx: Arm64AsmParser.Umulh3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b10011011110 shl 21
    val flags = 0b011111 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitSdiv3(ctx: Arm64AsmParser.Sdiv3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b10011010110 shl 21
    val flags = 0b000011 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitUdiv3(ctx: Arm64AsmParser.Udiv3Context): Void? {
    val rd = parseReg(ctx.reg(0).text)
    val rn = parseReg(ctx.reg(1).text)
    val rm = parseReg(ctx.reg(2).text)

    val opcode = 0b10011010110 shl 21
    val flags = 0b000010 shl 10

    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitCmpInstr(ctx: Arm64AsmParser.CmpInstrContext): Void? {
    val rn = parseReg(ctx.reg(0).text)
    val rm = parseReg(ctx.reg(1).text)
    val rd = 31 // For cmp, the destination register (rd) is implicitly xzr (register 31)

    val opcode = 0b11101011001 shl 21
    val flags = 0b011000 shl 10

    // Assemble the machine code by combining opcode, registers, and flags
    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitBrReg(ctx: Arm64AsmParser.BrRegContext): Void? {
    val rn = parseReg(ctx.reg().text)
    val rm = 31
    val rd = 0

    val opcode = 0b11010110000 shl 21
    val flags = 0b000000 shl 10

    // Assemble the machine code by combining opcode, registers, and flags
    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }

  override fun visitBlrReg(ctx: Arm64AsmParser.BlrRegContext): Void? {
    val rn = parseReg(ctx.reg().text)
    val rm = 31
    val rd = 0

    val opcode = 0b11010110001 shl 21
    val flags = 0b000000 shl 10

    // Assemble the machine code by combining opcode, registers, and flags
    val machineCode = opcode or (rm shl 16) or flags or (rn shl 5) or rd
    emit32(machineCode)
    return null
  }
}
